<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
</head>
<body>
	<canvas id="canvas" width="500" height="500"></canvas>
	<script type="text/javascript">
		function loadImage(fn) {
			return new Promise((resolve, reject) => {
				const img = new Image();
				img.addEventListener('load', () => resolve(img));
				img.addEventListener('error', e => reject(e));
				img.src = `sprites/${fn}.png`;
			});
		}

		function hex(n) {
			const str = n.toString(16);
			if (str.length === 1) return '0' + str;
			return str;
		}

		function col2hex(r, g, b, a) {
			return `#${hex(r)}${hex(g)}${hex(b)}${hex(a)}`;
		}

		function img2pix(image) {
			const canvas = document.createElement('canvas');
			canvas.width = image.naturalWidth;
			canvas.height = image.naturalHeight;
			const context = canvas.getContext('2d');
			context.drawImage(image, 0, 0);
			const { data } = context.getImageData(0, 0, canvas.width, canvas.height);
			console.log(canvas.width, canvas.height, data.length)
			const pixels = [];
			let i = 0;
			for (let y = 0; y < canvas.height; ++y) {
				const row = [];
				pixels.push(row);
				for (let x = 0; x < canvas.width; ++x) {
					console.log(x, y, i)
					row.push(col2hex(data[i++], data[i++], data[i++], data[i++]));
				}
			}
			return pixels;
		}

		function drawImage(context, pixels, pixelSize, positioner) {
			const d = pixelSize / 2;
			pixels.forEach((row, y) =>
				row.forEach((colour, x) => {
					const pos = positioner({ x, y });
					context.fillStyle = colour;
					context.fillRect(pos.x - d, pos.y - d, pixelSize, pixelSize);
				})
			);
		}

		function scale(sourceOffset, destOffset, scale) {
			return ({ x, y }) => ({
				x: destOffset + (x - sourceOffset) * scale,
				y: destOffset + (y - sourceOffset) * scale
			});
		}

		function skewX(centreY, ratio) {
			return ({ x, y }) => ({
				x: x + (y - centreY) * ratio,
				y
			});
		}

		function skewY(centreX, ratio) {
			return ({ x, y }) => ({
				x,
				y: y + (x - centreX) * ratio
			});
		}

		function roundX(offset, unit) {
			return ({ x, y }) => ({
				x: offset + unit * Math.floor((x - offset) / unit),
				y
			});
		}

		function lerp(transform, p) {
			return i => {
				const f = transform(i);
				const q = 1 - p;
				return {
					x: i.x * q + f.x * p,
					y: i.y * q + f.y * p
				};
			};
		}

		function lerp2(transformA, transformB, p) {
			return input => {
				const i = transformA(input);
				const f = transformB(input);
				const q = 1 - p;
				return {
					x: i.x * q + f.x * p,
					y: i.y * q + f.y * p
				};
			};
		}

		function rotate(centreX, centreY, theta) {
			const sin = Math.sin(theta);
			const cos = Math.cos(theta);
			return ({ x, y }) => {
				const dx = x - centreX;
				const dy = y - centreY;
				return {
					x: centreX + dx * cos + dy * sin,
					y: centreY + dy * cos - dx * sin
				};
			};
		}

		function stack(...transforms) {
			console.log(transforms);
			return input => transforms.reduce((a, n) => n(a), input);
		}

		(async function() {
			const image = await loadImage('mario');
			const pix = img2pix(image);
			const canvas = document.getElementById('canvas');
			const context = canvas.getContext('2d');
			console.log(pix);

			// drawImage(context, pix, 25, scale(8, 250, 28));

			// drawImage(context, pix, 25, stack(
			// 	scale(8, 250, 28),
			// 	lerp(
			// 		stack(
			// 			skewX(250, -0.3),
			// 			roundX(250, 28)
			// 		),
			// 		0.5
			// 	)
			// ));

			drawImage(context, pix, 15, stack(
				scale(8, 250, 20),
				rotate(250, 250, Math.PI / 6)
			));
		})();
	</script>
</body>
</html>